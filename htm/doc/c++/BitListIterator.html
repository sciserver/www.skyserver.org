<html><head><TITLE>BitListIterator</TITLE></head>
 <body text="#111111" bgcolor="#FFFFFF" link="#333399" vlink="#663366" alink="#CC0000">

<!--
Authors:        Peter Z. Kunszt
Created:        August 2000

 Copyright (C) 2000  Peter Z. Kunszt, Alex S. Szalay, Aniruddha R. Thakar
                     The Johns Hopkins University

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

-->
<h3>&nbsp;&nbsp;
<font color="#7700EE">HTM SpatialIndex Class Reference</font>
</h3>
<img SRC="rule.gif" width="400" height="5" >


<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif width="36" height="36"></A>  class  BitListIterator  </H2><BLOCKQUOTE>
BitListIterator class
</BLOCKQUOTE>
<hr>

<DL>
<TABLE BORDER>
<DT><h3>Public Methods</h3><DD><TR><TD VALIGN=top><A HREF="#DOC.18.6"> <IMG BORDER=0 SRC=icon1.gif width="14" height="14"></A> </TD><TD><B>BitListIterator</B> ()<br>
<I> Default Constructor.</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.1"> <IMG BORDER=0 SRC=icon1.gif width="14" height="14"></A> </TD><TD><B>BitListIterator</B> (const <!1><A HREF="BitList.html">BitList</A> & <!2><A HREF="BitListIterator.html#DOC.18.13">bitlist</A>)<br>
<I>Normal Constructor</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.2"> <IMG BORDER=0 SRC=icon1.gif width="14" height="14"></A> </TD><TD><B>BitListIterator</B> (const <!1><A HREF="BitList.html">BitList</A> & <!2><A HREF="BitListIterator.html#DOC.18.13">bitlist</A>, size_t start)<br>
<I>Alternate constructor</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.7"> <IMG BORDER=0 SRC=icon1.gif width="14" height="14"></A> </TD><TD><B>BitListIterator</B> (const <!2><A HREF="BitListIterator.html#DOC.18.6">BitListIterator</A> &)<br>
<I> Copy Constructor.</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.8"> <IMG BORDER=0 SRC=icon1.gif width="14" height="14"></A> <!2><A HREF="BitListIterator.html#DOC.18.6">BitListIterator</A>& </TD><TD><B>operator = </B> (const <!2><A HREF="BitListIterator.html#DOC.18.6">BitListIterator</A> &)<br>
<I> Assignment.</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.9"> <IMG BORDER=0 SRC=icon1.gif width="14" height="14"></A> void </TD><TD><B>setindex</B> (size_t index)<br>
<I> Init: set current index</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.3"> <IMG BORDER=0 SRC=icon1.gif width="14" height="14"></A> bool </TD><TD><B>next</B> (bool bit, size_t & _index)<br>
<I>Set the internal index to the next 'true' or 'false' bit;
indicated by the first argument, and return the index in the
second argument</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.10"> <IMG BORDER=0 SRC=icon1.gif width="14" height="14"></A> bool </TD><TD><B>prev</B> (bool bit, size_t & _index)<br>
<I> Just like next(), but the index is moved backwards.</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.4"> <IMG BORDER=0 SRC=icon1.gif width="14" height="14"></A> bool </TD><TD><B>next</B> (bool & bit)<br>
<I>Increment the internal index and return the value of the bit it points to
Returns 'false' if the boundary is reached</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.5"> <IMG BORDER=0 SRC=icon1.gif width="14" height="14"></A> bool </TD><TD><B>prev</B> (bool & bit)<br>
<I>Just like next() above, just decrement the internal index</I>
</TD></TR></TABLE></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>
BitListIterator class.
The BitListIterator iterates through a BitList efficiently.
next() and prev() functions are supplied. The functionality is
the following: The BLI saves an index to a certain bit in the BitList.
By calling either next() or prev(), the index is incremented/decremented and
the bit it is pointing to now is returned. If it gets out of bounds,
these functions return 'false'. The out-of-bounds index is always 
index=size. So by calling next() or prev() again when a 'false' was 
returned previously, they return the first/last bit, respectively.

</BLOCKQUOTE>
<DL>

<A NAME="BitListIterator">
<A NAME ="DOC.18.6">
<DT><IMG BORDER=0 SRC=icon2.gif width="14" height="14"><TT><B>  BitListIterator()</B></TT>
<DD> Default Constructor.
<DL></DL><P>
<A NAME="BitListIterator">
<A NAME ="DOC.18.1">
<DT><IMG BORDER=0 SRC=icon2.gif width="14" height="14"><TT><B>  BitListIterator(const <!1><A HREF="BitList.html">BitList</A> & <!2><A HREF="BitListIterator.html#DOC.18.13">bitlist</A>)</B></TT>
<DD>Normal Constructor.
needs the BitList to initialize.
The index is initialized to the out-of-bounds index. 
<DL></DL><P>
<A NAME="BitListIterator">
<A NAME ="DOC.18.2">
<DT><IMG BORDER=0 SRC=icon2.gif width="14" height="14"><TT><B>  BitListIterator(const <!1><A HREF="BitList.html">BitList</A> & <!2><A HREF="BitListIterator.html#DOC.18.13">bitlist</A>, size_t start)</B></TT>
<DD>Alternate constructor.
set the starting index yourself. 
<DL></DL><P>
<A NAME="BitListIterator">
<A NAME ="DOC.18.7">
<DT><IMG BORDER=0 SRC=icon2.gif width="14" height="14"><TT><B>  BitListIterator(const <!2><A HREF="BitListIterator.html#DOC.18.6">BitListIterator</A> &)</B></TT>
<DD> Copy Constructor.
<DL></DL><P>
<A NAME="operator = ">
<A NAME ="DOC.18.8">
<DT><IMG BORDER=0 SRC=icon2.gif width="14" height="14"><TT><B> <!2><A HREF="BitListIterator.html#DOC.18.6">BitListIterator</A>&  operator = (const <!2><A HREF="BitListIterator.html#DOC.18.6">BitListIterator</A> &)</B></TT>
<DD> Assignment.
<DL></DL><P>
<A NAME="setindex">
<A NAME ="DOC.18.9">
<DT><IMG BORDER=0 SRC=icon2.gif width="14" height="14"><TT><B> void  setindex(size_t index)</B></TT>
<DD> Init: set current index
<DL></DL><P>
<A NAME="next">
<A NAME ="DOC.18.3">
<DT><IMG BORDER=0 SRC=icon2.gif width="14" height="14"><TT><B> bool  next(bool bit, size_t & _index)</B></TT>
<DD>Set the internal index to the next 'true' or 'false' bit;
indicated by the first argument, and return the index in the
second argument.  Returns 'false' if it gets out of bounds.
Example: For a BitList 001100110011 (from left to right, index
starts at 0), the subsequent call to next(true,index) returns
'true' and sets index to 2, 3, 6, 7, 10, 11. The next call puts
leaves index and returns 'false'. A subsequent next() call would
again return 'true' and set index=2.
<DL></DL><P>
<A NAME="prev">
<A NAME ="DOC.18.10">
<DT><IMG BORDER=0 SRC=icon2.gif width="14" height="14"><TT><B> bool  prev(bool bit, size_t & _index)</B></TT>
<DD> Just like next(), but the index is moved backwards.
<DL></DL><P>
<A NAME="next">
<A NAME ="DOC.18.4">
<DT><IMG BORDER=0 SRC=icon2.gif width="14" height="14"><TT><B> bool  next(bool & bit)</B></TT>
<DD>Increment the internal index and return the value of the bit it points to
Returns 'false' if the boundary is reached.
<b>Example</b>: For a BitList 001100110011 the calls to next(val) return
'true' and set bit to 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1. The next call
returns 'false' and does not set bit. A subsequent call would return
again 'true' and set bit to the first bit in the list, in this case 0.
<DL></DL><P>
<A NAME="prev">
<A NAME ="DOC.18.5">
<DT><IMG BORDER=0 SRC=icon2.gif width="14" height="14"><TT><B> bool  prev(bool & bit)</B></TT>
<DD>Just like next() above, just decrement the internal index.
The two versions of next() and prev() may be used in conjunction.
<DL></DL><P></DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>

<img SRC="rule.gif" width="400" height="5" >
<h6>
&copy;
<A HREF = "http://www.sdss.jhu.edu/ScienceArchive/copyright.html">
Copyright 2000
</A>
Peter Z. Kunszt, Alex S. Szalay, Aniruddha R. Thakar
@ The Johns Hopkins University under the <a href="http://www.gnu.org/copyleft/gpl.txt">GNU GENERAL PUBLIC LICENSE</a><br>

<a href="mailto:kunszt@pha.jhu.edu">Peter Z. Kunszt</a>,
<br>
</h6>

</body>
</html>

<P Align=right><I>generated by <A HREF="http://www.zib.de/Visual/software/doc++/index.html">doc++</A></I>
</BODY>
